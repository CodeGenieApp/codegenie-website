---
title: 'AWS Cognito: Sign in and link Email, Google, and SSO (SAML) accounts'
date: 2024-02-31
excerpt: how to
authors:
  - brett
tags:
  - cognito
  - aws
---
import { Image } from 'astro:assets';
import { Tabs, TabItem } from '@astrojs/starlight/components'
import signInPage from '../../../assets/images/blog/aws-cognito-google-sso-saml-linked-accounts/cognito-example-sign-in.webp';

[Cognito User Pools](https://aws.amazon.com/cognito/) is an AWS service that provides user identity and auth -- a core component of almost every application. This article covers a full stack solution enabling users to sign in with Email + Password, Google Sign In, and SSO/SAML, and link them all to the same user within the app.

<figure style={{margin: '2rem auto', width: '360px'}}>
  <Image
    src={signInPage}
    alt="Sign in page"
  />
  <figcaption style={{margin: 0, color: '#666', fontSize: '0.8rem'}}>Pretty picture of the Login UI. This article deals mostly with the backend, but there are no pretty backend pictures.</figcaption>
</figure>

The complete source code is available by generating a [Code Genie](https://codegenie.codes) app and specifying `'Google'` and `'SAML'` `idp` options:

```sh title="Generate a To-Do List app with Code Genie"
npx @codegenie/cli generate --name "Todo"
--idp 'Google' --idp 'SAML'
--description "A todo list app that lets users create lists and add items to the list. Items should have a title, description, be markable as completed, have a due date, and have an image."
```

:::note[Terminology]
This example uses both Google Social Sign in, and Google SSO/SAML. So that we don't confuse the two, I'll just refer to the latter as the "SAML" Identity Provider (IDP) going forward. The terms "Federated" and "External" are used interchangeably.
:::

## Link Federated Identities to a single Cognito User with Lambda Triggers

Let's start with the interesting stuff first before we grind out some CDK, and click-ops our way through creating External IDPs. The core of this solution relies on two Cognito Triggers. The high-level flow looks like this:

1. The <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-sign-up.html" target="_blank" rel="noopener">Pre sign-up Trigger</a> fires when a user signs up using Google, SAML, or Email + Password. It's also triggered when an existing user signs in using a new external identity for the first time (e.g. if a user signs up using SAML and then later signs in using Google SSO with the same email).
    1. If they're signing up with Email + Password, no special logic is run.
    1. If they're signing up via Google or SAML and they haven't already signed up using a different method with the same email: a native Cognito User is created for that email.
    1. The External Identity is linked to the native Cognito User for that email.
1. The <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-token-generation.html" target="_blank" rel="noopener">Pre token generation Trigger</a> fires on every sign in.
    {/* 1. If this is their first time signing in, a User record is created in DynamoDB. */}
    1. If the user has External Identities linked to their account, the account is marked as verified.

:::note[Working around Cognito]
The reason we must create a native Cognito User is because Cognito doesn't allow linking a native Cognito User to an existing Federated Identity. To handle the scenario where a user first signs in with an External IDP and then later wants to sign in with Email + Password, we manually create a native Cognito User, and then link the External Identity. Users that choose to later sign in with Email+Pass can set their password via the "Forgot Password" flow to sign in with their Email + Password.

Additionally, there is an unfortunate Cognito "feature" that sets all User attributes to their default value when signing in with an External IDP that doesn't return that value. For `email_verified` this is `false`. We must keep `email_verified=true`, otherwise the user won't be able to sign in with their Email + Password or use the "Forgot Password" flow.

#AWSWishlist: fix these ☝️
:::

### Lambda Handlers

<Tabs>
<TabItem label="Pre Sign-up">

```typescript
import { randomBytes } from 'crypto'
import {
  AdminCreateUserCommand,
  AdminLinkProviderForUserCommand,
  AdminSetUserPasswordCommand,
  CognitoIdentityProviderClient,
  ListUsersCommand,
  MessageActionType,
} from '@aws-sdk/client-cognito-identity-provider'
import type { PreSignUpTriggerEvent } from 'aws-lambda'
import UnsupportedIdentityProviderNameException from './exceptions/UnsupportedIdentityProviderNameException'
import getFullName from './getFullName'

// NOTE: Cognito's adminLinkProviderForUser API requires the provider name to have the correct capitalization (e.g. Google, Facebook, MySamlIdp),
// however, the providerName received in the event from Cognito is lowercased, e.g. google_1234.
const providerNamesLowerCaseLookup = {
  'google': 'Google',
  // 'facebook': 'Facebook',
}

// GOOGLE_SAML_IDENTITY_PROVIDER_NAME is defined later in CDK and passed through as an environment variable.
const { GOOGLE_SAML_IDENTITY_PROVIDER_NAME } = process.env

if (GOOGLE_SAML_IDENTITY_PROVIDER_NAME) {
  providerNamesLowerCaseLookup[GOOGLE_SAML_IDENTITY_PROVIDER_NAME.toLowerCase()] = GOOGLE_SAML_IDENTITY_PROVIDER_NAME
}

const cognitoIdpClient = new CognitoIdentityProviderClient({ region: 'us-west-2' })

export async function handler (event: PreSignUpTriggerEvent) {
  switch(event.triggerSource) {
  case 'PreSignUp_ExternalProvider':
    await handleExternalProvider({ event })
    break
  case 'PreSignUp_SignUp':
  case 'PreSignUp_AdminCreateUser':
    if (process.env.AUTO_VERIFY_USERS) {
      event.response.autoConfirmUser = true
      event.response.autoVerifyEmail = true
    }
  }

  return event
}

async function handleExternalProvider({ event }: { event: PreSignUpTriggerEvent }) {
  const {
    userName,
    userPoolId,
    request: {
      userAttributes,
    },
  } = event

  const { email, name, given_name: givenName, family_name: familyName } = userAttributes
  const [providerName, providerUserId] = userName.split('_')
  const providerNameWithCorrectCapitalization = providerNamesLowerCaseLookup[providerName.toLowerCase()]

  if (!providerNameWithCorrectCapitalization) {
    throw new UnsupportedIdentityProviderNameException({ providerName, validIdentityProviderNamesMap: providerNamesLowerCaseLookup })
  }

  const cognitoUsersWithEmail = await listCognitoUsersWithEmail({ userPoolId, email })

  if (cognitoUsersWithEmail.Users?.length) {
    const cognitoUsername = cognitoUsersWithEmail.Users[0].Username || 'username-not-found'

    await linkCognitoUserAccounts({
      cognitoUsername,
      userPoolId,
      providerName: providerNameWithCorrectCapitalization,
      providerUserId,
    })
  } else {
    // No existing native Cognito user. Create one now in case they want to login with their email address in the future.
    // Cognito doesn't support linking a new native Cognito User to an existing Federated User, so it must be done now.
    // This approach allows users to use the Forgot Password flow to reset their password and sign in with email + password.
    const newNativeCognitoUser = await createCognitoUser({
      userPoolId,
      email,
      givenName,
      familyName,
      name,
    })

    const newNativeCognitoUserUsername = newNativeCognitoUser.User?.Username || 'username-not-found'

    await linkCognitoUserAccounts({
      cognitoUsername: newNativeCognitoUserUsername,
      userPoolId,
      providerName: providerNameWithCorrectCapitalization,
      providerUserId,
    })
  }

  return event
}

function listCognitoUsersWithEmail ({ userPoolId, email }: { userPoolId: string, email: string }) {
  return cognitoIdpClient.send(new ListUsersCommand({
    UserPoolId: userPoolId,
    Filter: `email = '${email}'`,
  }))
}

function linkCognitoUserAccounts ({
  cognitoUsername,
  userPoolId,
  providerName,
  providerUserId,
}: {
  cognitoUsername: string
  userPoolId: string
  providerName: string
  providerUserId: string
}) {
  return cognitoIdpClient.send(new AdminLinkProviderForUserCommand({
    SourceUser: {
      ProviderName: providerName,
      ProviderAttributeName: 'Cognito_Subject',
      ProviderAttributeValue: providerUserId,
    },
    DestinationUser: {
      ProviderName: 'Cognito',
      ProviderAttributeValue: cognitoUsername,
    },
    UserPoolId: userPoolId,
  }))
}

async function createCognitoUser ({
  userPoolId,
  email,
  givenName,
  familyName,
  name,
}: {
  userPoolId: string
  email: string
  givenName: string
  familyName: string
  name: string
}) {
  const fullName = getFullName({ name, givenName, familyName })
  const createdCognitoUser = await cognitoIdpClient.send(new AdminCreateUserCommand({
    UserPoolId: userPoolId,
    // Don't send an email with the temporary password
    MessageAction: MessageActionType.SUPPRESS,
    Username: email,
    UserAttributes: [
      {
        Name: 'name',
        Value: fullName,
      },
      {
        Name: 'email',
        Value: email,
      },
      {
        Name: 'email_verified',
        Value: 'true',
      },
    ],
  }))

  // Set password to confirm user; AdminConfirmSignUp doesn't work on manually created users
  await setCognitoUserPassword({ userPoolId, email })

  return createdCognitoUser
}

function setCognitoUserPassword ({ userPoolId, email }: { userPoolId: string, email: string }) {
  const password = randomBytes(16).toString('hex')

  return cognitoIdpClient.send(new AdminSetUserPasswordCommand({
    Password: password,
    UserPoolId: userPoolId,
    Username: email,
    Permanent: true,
  }))
}
```
:::tip
That was a lot of code, but we're not done yet! Don't forget to [scroll back up](#lambda-handlers) and see the Pre Token Generation Lambda Handler.
:::
</TabItem>
<TabItem label="Pre Token Generation">
```typescript
import { AdminUpdateUserAttributesCommand, CognitoIdentityProviderClient } from '@aws-sdk/client-cognito-identity-provider'
import axios from 'axios'
import type { PreTokenGenerationTriggerEvent } from 'aws-lambda'
import { createUser, getUser, updateUser } from '../api/controllers/user'
import { StringMap } from '../common/types'
import getFullName from './getFullName'

const cognitoIdpClient = new CognitoIdentityProviderClient({ region: 'us-west-2' })

interface Identity {
  providerType: 'Google' | 'Facebook' | 'SAML' | 'OIDC' | string
}

export async function handler (event: PreTokenGenerationTriggerEvent) {
  const {
    userPoolId,
    userName,
    request: {
      userAttributes,
    },
  } = event
  const promises: Promise<any>[] = [syncUserToDynamo(userAttributes)]

  const { identities, email } = userAttributes

  if (email && identities) {
    const identitiesArray: Identity[] = JSON.parse(identities)
    const hasExternalIdentity = identitiesArray.some(identity => ['Google', 'Facebook', 'SAML', 'OIDC'].includes(identity.providerType))

    if (hasExternalIdentity) {
      // Cognito has a "feature" that sets all attributes to their default values when not present on the external identity provider.
      // This results in the email_verified being set to false on each login, which causes features like forgot password to not work.
      // Force it back to email_verified=true.
      promises.push(setUserEmailVerifiedTrue({
        userPoolId,
        username: userName,
      }))
    }
  }

  await Promise.all(promises)

  return event
}

async function setUserEmailVerifiedTrue ({
  userPoolId,
  username,
}: {
  userPoolId: string
  username: string
}) {
  return cognitoIdpClient.send(new AdminUpdateUserAttributesCommand({
    UserPoolId: userPoolId,
    Username: username,
    UserAttributes: [{Name: 'email_verified', Value: 'true'}],
  }))
}

async function syncUserToDynamo (userAttributes: StringMap) {
  const {
    sub: userId,
    email,
    given_name: givenName,
    family_name: familyName,
    name,
    picture,
  } = userAttributes

  const fullName = getFullName({ name, givenName, familyName })
  const existingUser = await getUser({ userId })

  if (existingUser) {
    // If the user doesn't have an avatar set and one is available from the external IDP: set it to the user's avatar
    if (picture && !existingUser.data.avatar) {
      const base64EncodedProfilePicture = await fetchAndBase64EncodeImage(picture)
      await updateUser({ userId, user: { avatar: base64EncodedProfilePicture }})
    }
    return
  }

  const user: any = {
    name: fullName,
    email,
  }

  if (picture) {
    const base64EncodedProfilePicture = await fetchAndBase64EncodeImage(picture)

    if (base64EncodedProfilePicture) {
      user.avatar = base64EncodedProfilePicture
    }
  }

  return createUser({ userId, user })
}

async function fetchAndBase64EncodeImage(imageUrl) {
  try {
    const image = await axios.get(imageUrl, {responseType: 'arraybuffer'})
    const base64 = Buffer.from(image.data).toString('base64')
    return base64 ? `data:image/png;base64, ${base64}` : null
  } catch(error: unknown) {
    // If we encounter an error while fetching/encoding the image, it's better to just log and continue.
    // The user won't have their profile picture, but at least they'll be registered/logged in!
    console.error('cognito.preTokenGeneration.syncUserToDynamo.fetchAndBase64EncodeImage.error', {
      errorName: (error as Error).name,
      errorMessage: (error as Error).message,
    })
  }
}
```
</TabItem>
<TabItem label="getFullName">
```typescript
// Google SAML doesn't allow mapping the full name field, so we instead must construct this ourselves based on Given Name and Family Name.
export default function getFullName({ name, givenName, familyName}) {
  let fullName = name

  // If the name is JUST the given name, AND a family name exists: concatenate them into full name.
  // This is especially useful in Google SAML where it doesn't include a full name attribute.
  if (givenName && familyName && (!fullName || fullName === givenName)) {
    fullName = `${givenName} ${familyName}`
  } else if (!fullName) {
    fullName = givenName || familyName
  }

  return fullName
}
```
</TabItem>
</Tabs>

## Register and sign in to Cognito via the frontend web app using Amplify library

"Amplify" is one of those AWS services that saw some early initial success so they decided to name a bunch of things "Amplify" to try and ride the wave but ultimately end up confusing customers. The one we're interested in is the original Amplify: <a href="https://docs.amplify.aws/" target="_blank" rel="noopener">Amplify JavaScript Library</a>.  It provides some excellent abstractions to many backend AWS resources that clients need to interact with. Here we're only interested in the `Authentication` module to simplify the complex <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-authentication-flow.html" target="_blank" rel="noopener">OAuth flow</a>.

```typescript

import { Amplify } from 'aws-amplify'
import { fetchAuthSession } from 'aws-amplify/auth'
import axios from 'axios'

const oauthRedirectUrl = ['http://localhost:3001/']

if (global.window?.location.origin) oauthRedirectUrl.push(global.window.location.origin)

Amplify.configure({
  Auth: {
    Cognito: {
      userPoolId: process.env.NEXT_PUBLIC_CognitoUserPoolId!,
      userPoolClientId: process.env.NEXT_PUBLIC_CognitoUserPoolClientId!,
      loginWith: {
        oauth: {
          redirectSignIn: oauthRedirectUrl,
          redirectSignOut: oauthRedirectUrl,
          domain: 'example.auth.us-west-2.amazoncognito.com',
          responseType: 'code',
          scopes: ['aws.cognito.signin.user.admin', 'email', 'openid', 'phone', 'profile'],
        },
      },
    },
  },
}, {
  ssr: false,
})

axios.defaults.baseURL = process.env.NEXT_PUBLIC_ApiEndpoint

// Set Authorization header on all requests if user is signed in; othwerise, redirect to login page
axios.interceptors.request.use(async (config) => {
  try {
    const authSession = await fetchAuthSession()
    config.headers.Authorization = authSession.tokens?.idToken?.toString()
  } catch (e) {
    const redirectRoute = getRedirectToLoginPageUrl()
    global.window.location.href = redirectRoute
  }

  return config
})
```

## Create Cognito User Pool with CDK

We'll use [CDK](https://docs.aws.amazon.com/cdk/v2/guide/home.html) to create our Cognito User Pool and other AWS resources. The following CDK constructs retrieves config from a `cdk.json` that looks like this:

```json
{
  "app": "ts-node --prefer-ts-exts bin/cdk.ts",
  "context": {
    "environmentConfig": {
      "development": {...},
      "staging": {...},
      "production": {
        "auth": {
          "autoVerifyUsers": false,
          "googleClientId": "",
          "googleClientSecret": ""
        },
        "logRetentionInDays": 14,
        "ui": {
          "domainName": "app.example.com"
        }
      }
    }
  }
}
```

### Cognito User Pool with CDK

```typescript {26-27}
...
const googleIDPMetadataPath = path.resolve(__dirname, '../../GoogleIDPMetadata.xml')
const googleIDPMetadataExists = existsSync(googleIDPMetadataPath)
const cognitoPackageDir = path.resolve(__dirname, '../../../cognito')
const GOOGLE_SAML_IDENTITY_PROVIDER_NAME = 'GoogleSaml'

interface AuthProps {
  userTable: ITable
  webAppUrl: string
}

export default class Auth extends Construct {
  readonly userPool: UserPool
  readonly userPoolClient: UserPoolClient
  constructor(scope: Construct, id: string, props: AuthProps) {
    super(scope, id)

    this.userPool = this.createUserPool()
    this.userPoolClient = this.createUserPoolClient({ additionalOauthCallbackUrls: props.additionalOauthCallbackUrls })
    this.addDomainName()
    this.addTriggers({ userTable: props.userTable })
  }

  createUserPool() {
    const userPool = new UserPool(this, 'UserPool', {
      signInCaseSensitive: false,
      removalPolicy: getRemovalPolicy({ node: this.node }),
      passwordPolicy: {
        minLength: 8,
      },
      selfSignUpEnabled: true,
      signInAliases: {
        username: false,
        email: true,
      },
    })

    new CfnOutput(this, 'UserPoolId', { key: 'UserPoolId', value: userPool.userPoolId })

    return userPool
  }
  ...
}
```
You can ignore the first 4 lines that deal with the Google SAML Metadata and Name for now. They'll be used later in [Cognito User Pool Identity Providers with CDK](#cognito-user-pool-identity-providers-with-cdk)
:::tip
Always specify `signInCaseSensitive: false`. By default, User Pools treat usernames/emails as case sensitive, resulting in foo@bar.com and Foo@bar.com being treated as two separate users.

For production environments, specify `removalPolicy: cdk.RemovalPolicy.RETAIN` to protect against accidentally deleting your User Pool (and users along with it).
:::

### Cognito User Pool Client with CDK

```typescript {15-19} {25-28}
createUserPoolClient({ webAppUrl }: { webAppUrl: string }) {
  const environmentConfig = getEnvironmentConfig(this.node)
  const googleIdentityProvider = this.createGoogleIdentityProvider()
  const googleSamlIdentityProvider = this.createGoogleSamlIdentityProvider()
  const supportedIdentityProviders: {name: string}[] = []

  if (googleIdentityProvider) {
    supportedIdentityProviders.push({ name: googleIdentityProvider.providerName })
  }

  if (googleSamlIdentityProvider) {
    supportedIdentityProviders.push({ name: googleSamlIdentityProvider.providerName })
  }

  const callbackUrls = ['http://localhost:3001']

  if (webAppUrl) {
    callbackUrls.push(webAppUrl)
  }

  const userPoolClient = this.userPool.addClient('UserPoolClient', {
    idTokenValidity: Duration.days(1),
    refreshTokenValidity: Duration.days(90),
    supportedIdentityProviders,
    oAuth: {
      callbackUrls: callbackUrls,
      logoutUrls: callbackUrls,
    },
  })

  if (googleIdentityProvider) {
    userPoolClient.node.addDependency(googleIdentityProvider)
  }

  if (googleSamlIdentityProvider) {
    userPoolClient.node.addDependency(googleSamlIdentityProvider)
  }

  new CfnOutput(this, 'UserPoolClientId', { key: 'UserPoolClientId', value: userPoolClient.userPoolClientId })

  return userPoolClient
}
```

We specify up to 2 OAuth callback URLs:

1. `http://localhost:3001/` for local development. Consider removing this for production.
1. `webAppUrl` The live web app URL. In Code Genie, this is passed in as either the web app's custom domain name (if one is defined in cdk.json for the environment we're deploying) or the default Amplify Hosting URL.

### Cognito User Pool Identity Providers with CDK

```typescript {10-17}
createGoogleIdentityProvider() {
  const { auth } = getEnvironmentConfig(this.node)

  if (!auth.googleClientId && !auth.googleClientId) return

  const googleIdentityProvider = new UserPoolIdentityProviderGoogle(this, 'GoogleIdp', {
    userPool: this.userPool,
    clientId: auth.googleClientId,
    clientSecret: auth.googleClientSecret,
    scopes: ['profile', 'email', 'openid'],
    attributeMapping: {
      email: ProviderAttribute.GOOGLE_EMAIL,
      fullname: ProviderAttribute.GOOGLE_NAME,
      familyName: ProviderAttribute.GOOGLE_FAMILY_NAME,
      givenName: ProviderAttribute.GOOGLE_GIVEN_NAME,
      profilePicture: ProviderAttribute.GOOGLE_PICTURE,
    },
  })
  new CfnOutput(this, 'GoogleIdpName', { key: 'GoogleIdpName', value: googleIdentityProvider.providerName })

  return googleIdentityProvider
}
```

Define the scopes and attributes from the External IDP that we want to store against our User in our User Pool. We're grabbing the `profilePicture` so that we can display the user's profile picture against their name.

```typescript {2} {7} {10-15}
createGoogleSamlIdentityProvider() {
  if (!googleIDPMetadataExists) return null
  const googleIdpMetadataContents = readFileSync(googleIDPMetadataPath, 'utf-8')
  const userPoolIdentityProviderSamlMetadata = UserPoolIdentityProviderSamlMetadata.file(googleIdpMetadataContents)

  const googleSamlIdentityProvider = new UserPoolIdentityProviderSaml(this, 'GoogleSamlIdp', {
    name: GOOGLE_SAML_IDENTITY_PROVIDER_NAME,
    userPool: this.userPool,
    metadata: userPoolIdentityProviderSamlMetadata,
    attributeMapping: {
      email: ProviderAttribute.GOOGLE_EMAIL,
      fullname: ProviderAttribute.GOOGLE_NAME,
      familyName: ProviderAttribute.GOOGLE_FAMILY_NAME,
      givenName: ProviderAttribute.GOOGLE_GIVEN_NAME,
    },
  })
  new CfnOutput(this, 'GoogleSamlIdpName', { key: 'GoogleSamlIdpName', value: googleSamlIdentityProvider.providerName })

  return googleSamlIdentityProvider
}
```

There's a circular dependency between the Cognito User Pool and the SAML App you create in Google Cloud/Workspace. Exit early if no `GoogleIDPMetadata.xml` file exists. When you create the SAML App, you'll need to provide the `UserPoolRedirectUrlACS` and `UserPoolEntityId` values from `cdk-outputs.development.json`. Download the SAML App's metadata file and redeploy your CDK Stack.

We must hardcode the SAML Identity Provider name (`GOOGLE_SAML_IDENTITY_PROVIDER_NAME`) to prevent a second circular dependency between the SAML Identity Provider and the `PreSignup` Cognito Trigger (which we'll meet soon). It doesn't seem like this should be a circular dependency since both resources are attached to the User Pool and the SAML Identity Provider has nothing to do with Triggers, but CDK will give you a "Circular dependency between resources" nonetheless.

Our attribute mappings for the SAML Identity Provider are similar to the Google Identity Provider. Unfortunately we don't have access to a profile picture, and even though we're requesting `fullname` here, Google doesn't allow you to map it when creating the SAML App. We'll handle this later.

### Cognito User Pool Lambda Triggers with CDK

```typescript {21-23} {25} {41-50}
addTriggers({ userTable }: { userTable: ITable }) {
  this.addPreSignupTrigger()
  this.addPreTokenGenerationTrigger({  userTable  })
}

// Pre Signup https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-sign-up.html
addPreSignupTrigger() {
  const { auth, logRetentionInDays } = getEnvironmentConfig(this.node)
  const isSourceMapsEnabled = getIsSourceMapsEnabled({ node: this.node })

  const cognitoPreSignupLogGroup = new LogGroup(this, 'PreSignupLogGroup', {
    retention: logRetentionInDays,
  })

  const environment: StringMap = {}

  if (isSourceMapsEnabled) {
    environment.NODE_OPTIONS = '--enable-source-maps'
  }

  if (auth?.autoVerifyUsers) {
    environment.AUTO_VERIFY_USERS = '1'
  }

  environment.GOOGLE_SAML_IDENTITY_PROVIDER_NAME = GOOGLE_SAML_IDENTITY_PROVIDER_NAME

  const cognitoPreSignupFunction = new NodejsFunction(this, 'PreSignupFunction', {
    runtime: Runtime.NODEJS_20_X,
    handler: 'handler',
    entry: path.join(cognitoPackageDir, 'cognito-pre-signup.ts'),
    timeout: Duration.seconds(10),
    memorySize: 1024,
    logGroup: cognitoPreSignupLogGroup,
    bundling: {
      sourceMap: isSourceMapsEnabled,
    },
    environment,
  })
  const updateCognitoUserPoolPolicyStatement = new PolicyStatement({
    effect: Effect.ALLOW,
    actions: [
      'cognito-idp:AdminUpdateUserAttributes',
      'cognito-idp:AdminLinkProviderForUser',
      'cognito-idp:AdminCreateUser',
      'cognito-idp:AdminSetUserPassword',
      'cognito-idp:ListUsers',
    ],
    resources: [
      `arn:aws:cognito-idp:${Aws.REGION}:${Aws.ACCOUNT_ID}:userpool/*`,
    ],
  })
  cognitoPreSignupFunction.addToRolePolicy(updateCognitoUserPoolPolicyStatement)
  this.userPool.addTrigger(UserPoolOperation.PRE_SIGN_UP, cognitoPreSignupFunction)
}
```

Setting `AUTO_VERIFY_USERS` in development and testing environments is really convenient. It's just as convenient in production, but there are good reasons to require email confirmation (such as GDPR).

We add our `GOOGLE_SAML_IDENTITY_PROVIDER_NAME` environment variable since we'll need that in the Lambda Function's code.

Our Lambda Function requires 5 permissions for the User Pool. Unfortunately we can't specify `this.userPool.userPoolArn` as the resource since CDK once again complains about a circular dependency. We're left with granting access to all User Pools within the same account and region.

```typescript {34-36} {48}
addPreTokenGenerationTrigger({ userTable }: { userTable: ITable }) {
  // Pre Token Generation https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-token-generation.html
  const { logRetentionInDays } = getEnvironmentConfig(this.node)
  const isSourceMapsEnabled = getIsSourceMapsEnabled({ node: this.node })
  const cognitoPreTokenGenerationLogGroup = new LogGroup(this, 'PreTokenGenerationLogGroup', {
    retention: logRetentionInDays,
  })

  const environment: StringMap = {
    USER_TABLE: userTable.tableName,
  }

  if (isSourceMapsEnabled) {
    environment.NODE_OPTIONS = '--enable-source-maps'
  }

  const cognitoPreTokenGenerationFunction = new NodejsFunction(this, 'PreTokenGenerationFunction', {
    runtime: Runtime.NODEJS_20_X,
    handler: 'handler',
    entry: path.join(cognitoPackageDir, 'cognito-pre-token-generation.ts'),
    timeout: Duration.seconds(10),
    memorySize: 1024,
    logGroup: cognitoPreTokenGenerationLogGroup,
    bundling: {
      sourceMap: isSourceMapsEnabled,
    },
    environment,
  })

  // Give the Lambda function permission to read and write to DynamoDB
  const dynamoDBReadWritePolicy = new PolicyStatement({
    effect: Effect.ALLOW,
    actions: [
      'dynamodb:GetItem',
      'dynamodb:PutItem',
      'dynamodb:UpdateItem',
    ],
    resources: [
      userTable.tableArn,
    ],
  })
  cognitoPreTokenGenerationFunction.addToRolePolicy(dynamoDBReadWritePolicy)

  // Give the Lambda function permission to update Cognito User Attributes
  const updateCognitoUserPoolPolicyStatement = new PolicyStatement({
    effect: Effect.ALLOW,
    actions: [
      'cognito-idp:AdminUpdateUserAttributes',
    ],
    resources: [
      `arn:aws:cognito-idp:${Aws.REGION}:${Aws.ACCOUNT_ID}:userpool/*`,
    ],
  })
  cognitoPreTokenGenerationFunction.addToRolePolicy(updateCognitoUserPoolPolicyStatement)
  this.userPool.addTrigger(UserPoolOperation.PRE_TOKEN_GENERATION, cognitoPreTokenGenerationFunction)
}
```

:::tip
You can create your own CDK Constructs to abstract away some of the repetitiveness you see in these Node.js Lambda Functions.
:::

## Create Google Internal and External Apps

## Create Google SAML App
1. Login to Google Workspace Admin and navigate to [Apps => Web and Mobile Apps](https://admin.google.com/ac/apps/unified).
1. Click "Add app" => "Add custom SAML App". Enter a name for your app.
1. Download the metadata file to `./packages/cdk` and click Continue.
1. From `cdk-outputs.development.json`, copy the values for `UserPoolRedirectUrlACS` and `UserPoolEntityId` and paste them into the respective fields in the Service Provider Details form and click Continue.
1. Add attribute mappings: Primary email => email; First name => first_name; Last name => family_name. Click Finish.
1. Click the User Access card; select "ON for everyone" and click Save.
1. Run `npm run deploy:dev`

## End

Multi-account linking between external identity providers and native Cognito Users isn't simple, but it is possible thanks to Lambda Triggers.
If you want to try this out yourselfj